#!/usr/bin/python3

import argparse
import multiprocessing
import subprocess
import sys


# global counter
counter = None

# once we parse our command line arguments, we'll store the results globally
# here
args = None

# FIXME: add build system glue to sed these values in prior to install
PROG_NAME="Pingenator"
BIN_NAME="pingenator"
VERSION="0.1.0"

desc = """\
{} v{} - a super ping tool to get you places
Copyright (C) 2021 Michael D Labriola <veggiemike@sourceruckus.org>
""".format(PROG_NAME, VERSION)

epi = """\
For example, to check reachability of public DNS servers provided by Google,
Cloudflare, Quad9, OpenDNS, and Comodo Secure DNS:

    {} 8.8.8.8 8.8.4.4 1.1.1.1 1.0.0.1 9.9.9.9 149.112.112.112 \\
        208.67.222.222 208.67.220.220 8.26.56.26 8.20.247.20

""".format(BIN_NAME)


# public dns servers
dns_ips = ["8.8.8.8", "8.8.4.4", # google
           "1.1.1.1", "1.0.0.1", # cloudflare
           "9.9.9.9", "149.112.112.112", # quad9
           "208.67.222.222", "208.67.220.220", # opendns
           "8.26.56.26", "8.20.247.20", # comodo secure dns
           ]


p = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                            prog='pingenator',
                            description=desc.rstrip(),
                            epilog=epi.rstrip()
                            )

p.add_argument('-V', '--version', action='version',
               version="{} version {}".format(PROG_NAME, VERSION))

p.add_argument('-v', '--verbose', action='count', default=1, dest='verbosity',
               help="""Be verbose.  Can be supplied multiple times for
                    increased levels of verbosity.""")

p.add_argument('-q', '--quiet', action='store_true',
               help="""Be quiet.  Only output is "N of N reached".""")

# FIXME: add type=ipaddr type checking... could just check that we can encode
#        the IP as either an IPv4 or IPv6 address, but we'll have to allow dns
#        resolution too
#
#        this would be really nice, because spotting a typo in the output after
#        waiting a few seconds will be hard on tired eyes.
#
p.add_argument('ip_list', metavar='IPADDR', nargs='*',
               help="""IP address to ping.""")

p.add_argument('-d', '--dns', action='store_true', dest='use_dns_ips',
               help="""Additionally use built-in IPs of Public DNS servers
                    provided by Google, Cloudflare, Quad9, OpenDNS, and
                    Comodo Secure DNS.""")

p.add_argument('-e', '--exclude', action='append', metavar='IP',
               dest='exclude_ips', default=[],
               help="""Do not ping specified IP, even if it's been specified.
                    This can be used to exclude IPs added via the --dns flag.
                    Can be specified multiple times.""")


def check_ip(ip):
    status = subprocess.run(["ping", "-w1", ip], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if status.returncode == 0:
        return True, status
    return False, status


def worker(ip):
    reachable, status = check_ip(ip)
    with counter.get_lock():
        if reachable:
            counter.value += 1
        # we do this here, with counter locked, to synchronize stdout from
        # within our subprocesses.
        if args.verbosity > 1:
            print(status)
        elif args.verbosity > 0:
            print(status.stdout.decode())



# NOTE: if we want to call this from the interpreter for testing, we'll have to
#       forge sys.argv
#
def main():
    global args
    args = p.parse_args()
    if args.quiet:
        args.verbosity = 0
    if args.verbosity > 1:
        print(args)

    if args.use_dns_ips:
        if args.verbosity > 1:
            print("adding to ip_list:", dns_ips)
        args.ip_list.extend(dns_ips)

    for ip in args.exclude_ips:
        if args.verbosity > 1:
            print("removing from ip_list:", ip)
        try:
            args.ip_list.remove(ip)
        except:
            pass

    if len(args.ip_list) == 0:
        print("ERROR: no IPs specified")
        sys.exit(1)

    global counter
    counter = multiprocessing.Value('i', 0)
    if args.verbosity > 1:
        print(counter)

    pool = multiprocessing.Pool(len(args.ip_list))
    i = pool.map_async(worker, args.ip_list, chunksize=1)
    i.wait()
    
    print(counter.value, "of", len(args.ip_list), "reached")




if __name__ == "__main__":
    main()
